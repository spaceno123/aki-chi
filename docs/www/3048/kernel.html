<html><head><title>kernel manual</title></head>
<body bgcolor="#c0c0e0">
<pre>
<h1>
組み込み型リアルタイム・マイクロ・カーネル</h1>
<br>
<h2>	【概要】</h2><br>
	　このカーネルは、μＩＴＲＯＮ３．０を目指して作成していますが、
	レベルＲに達していないので、μＩＴＲＯＮ３．０とは呼べません。
	もっとも、性能的にリアルタイム性に欠けているので、μＩＴＲＯＮ３．０
	と呼べる日は来ないでしょう。
	また、リリース０．０７をもってひとまず終了です。（内容的には０．０６ｃ
	の方が安定していますが）次は、μＩＴＲＯＮ４．０だからか．．．
<br>
<h2>	【目次】</h2><br>
<h3>	１．動作条件 <a href="#part1">▽</a>

	２．サポートシステムコール <a href="#part2">▽</a>

	３．使用方法 <a href="#part3">▽</a>
	　3- 1. カーネル起動 (vini_rtmk) <a href="#part31">▽</a>
	　3- 2. タスク生成 (cre_tsk) <a href="#part32">▽</a>
	　3- 3. タスク起動 (sta_tsk) <a href="#part33">▽</a>
	　3- 4. ディスパッチ禁止 (dis_dsp) <a href="#part34">▽</a>
	　3- 5. ディスパッチ許可 (ena_dsp) <a href="#part35">▽</a>
	　3- 6. タスクのレディキュー回転 (rot_rdq) <a href="#part36">▽</a>
	　3- 7. 自タスクのタスクＩＤ参照 (get_tid) <a href="#part37">▽</a>
	　3- 8. 自タスクを起床待ち状態へ移行 (slp_tsk,tslp_tsk) <a href="#part38">▽</a>
	　3- 9. 他タスクの起床 (wup_tsk) <a href="#part39">▽</a>
	　3-10. 割り込みハンドラから復帰 (ret_int) <a href="#part310">▽</a>
	　3-11. 割り込みとディスパッチ禁止 (loc_cpu) <a href="#part311">▽</a>
	　3-12. 割り込みとディスパッチ許可 (unl_cpu) <a href="#part312">▽</a>
	　3-13. タスク遅延 (dly_tsk) <a href="#part313">▽</a>
	　3-14. システム状態参照 (ref_sys) <a href="#part314">▽</a>
	　3-15. 自タスク終了 (ext_tsk) <a href="#part315">▽</a>
	　3-16. 自タスクの終了と削除 (exd_tsk) <a href="#part316">▽</a>
	　3-17. 例外ハンドラ定義 (def_exc) <a href="#part317">▽</a>
	　3-18. 他タスク強制終了 (ter_tsk) <a href="#part318">▽</a>
	　3-19. タスクの起床要求を無効化 (can_wup) <a href="#part319">▽</a>
	  3-20. 割り込みハンドラ復帰とタスク起床 (ret_wup) <a href="#part320">▽</a>
	  3-21. 割り込みハンドラ定義 (def_int) <a href="#part321">▽</a>

	４．配布内容 <a href="#part4">▽</a>
	　4- 1. カーネル <a href="#part41">▽</a>
	　4- 2. ＣＰＵのＣＣＲ操作関数 <a href="#part42">▽</a>
	　4- 3. ＬＣＤ表示ドライバ <a href="#part43">▽</a>
	　4- 4. セットアップ <a href="#part44">▽</a>
	　4- 5. サンプルファイル <a href="#part45">▽</a>

	５．組み込み手順 <a href="#part5">▽</a>

	６．注意事項 <a href="#part6">▽</a>

	７．その他 <a href="#part7">▽</a>
</h3><br>
<a name="part1"></a>
<h2>	１．動作条件
</h2>
	　AKI-H8マイコン専用Ｃコンパイラ（C38HAB.LIBをリンク）
	　タイマーを１チャンネル使用（１ｍＳｅｃインターバル用）

	　※ディスパッチには、setjmp, longjmp を使用しています。
	　　C38HAB.LIB のバージョンによっては、コードが異なる場合が
	　　あるかもしれません。その場合は、動作しませんので、諦め
	　　てください。（setjmp, longjmp に合わせて、カーネルを再構
	　　築する必要があるのですが、ソースの提供はありません。）

<a name="part2"></a>
<h2>	２．サポートシステムコール
</h2>
	レベルＲ，ＲＮ

		dis_dsp, ena_dsp, slp_tsk, loc_cpu, unl_cpu, ret_int, wup_tsk

	レベルＳ，ＳＮ

		ext_tsk, rot_rdq, get_tid, dly_tsk, sta_tsk, ter_tsk, can_wup

	レベルＥ，ＥＮ

		exd_tsk, tslp_tsk, ref_sys, cre_tsk, ret_wup

	レベルＣ

		def_exc, def_int

	※ご注意！　接続機能はサポートしていません。また、ほとんどデバッグして
	いません。

<a name="part3"></a>
<h2>	３．使用方法
</h2>
	　このカーネルは、パーソナルメディアから発売されている
	「μＩＴＲＯＮ３．０標準ハンドブック改定新版」
	をもとに作成しています。システムコール等の使用方法は、そちらを
	参照してください。

<a name="part31"></a>
<h3>	3-1. カーネル起動 (vini_rtmk)
</h3>
	　vini_rtmk:	Vender Initialize Real Time Micro Kernel

	【パラメータ】

	　ID		tskid	TaskId			タスクＩＤ
	　T_CTSK*	pk_ctsk	Packet to Create Task	タスク生成情報

	pk_ctskの内容

	　VP		exinf	Extended Information	拡張情報
	　ATR		tskatr	TaskAttribute		タスク属性
	　FP		task	TaskStartAddress	タスク起動アドレス
	　PRI		itskpri	InitialTaskPriority	タスク起動時優先度
	　INT		stksz	StackSize		スタックサイズ(バイト数)
	　−（☆以下はＴＣＢとしてカーネルが使用する領域がある）−

	【リターンパラメータ】

	　ER		ercd	ErrorCode		エラーコード

	【解説】

	　tskidで指定したID番号を持つユーザータスクを現在実行中の状態として
	生成すると同時に、カーネルの初期化を行います。
	　対象タスクは生成後、RUN状態となります。

	※他の点は cre_tsk に準じていますので、ハンドブックをご参照ください。

	【補足事項】

	　SETUP.MAR から、main をコールした時点ではまだ、カーネルは動作して
	いません。T_CTSK 構造体を確保して、パラメータをセットしてから、
	vini_rtmk をコールします。

        /* rtmk initialize */
        main_task.exinf = NULL;			/* 拡張情報（未指定） */
        main_task.tskatr = TA_HLNG;		/* 対象タスクが高級言語 */
        main_task.task = main;			/* スタートアドレス */
        main_task.itskpri = 8;			/* タスク優先順位 */
        main_task.stksz = 512;			/* スタック割り当てサイズ */
        if ( vini_rtmk( MAIN_TASK, &main_task ) != E_OK )
		return -1;

	　vini_rtmk では、現在実行中の状態を１タスクとして組み込んで、
	カーネルの使用するタイマーを起動します。

	　ここで使用した T_CTSK 構造体は、カーネル起動後にカーネルがそのま
	ま参照しています（ＴＣＢがこの構造体に含まれています）ので、他のタ
	スクの登録には、別途 T_CTSK 構造体を確保する必要があります。

	　カーネルの参照するアドレス等をスタートアップ等で定義してください。
	　_ITUx		カーネルに割り当てるＩＴＵのアドレスを定義します。
	　(ITU0:H'ffff64,ITU1:H'ffff6e,ITU2:ffff78,ITU3:H'ffff82,ITU4:H'ffff92)
	　_CNT1mS	１ｍＳｅｃのシステムクロックでのカウント値を定義します。
	　_STKtop	スタックエリアの最下位アドレスを定義します。
	　_STKini	スタックエリアの最上位アドレス＋１を定義します。

	        .section        C, DATA, ALIGN=2
	        .export _ITUx, _CNT1mS, _STKtop, _STKini
	_ITUx   .data.l H'ffff6e        ; カーネルの使用するＩＴＵを定義（ＩＴＵ１）
	_CNT1mS .data.w 16000           ; 1mSec のカウント数を定義（φ＝１６ＭＨｚ）
	_STKtop .data.l startof S       ; スタック開始アドレス
	_STKini .data.l stack           ; 割り当てスタック初期値

	【エラーコード(ercd)】

	　E_OK		正常終了
	　E_SYS		システムエラー（既にカーネル初期化済み）
	　E_ID		不正ID番号（tskidが不正）
	　E_PAR		パラメータエラー（task,itskpri,stkszが不正）

<a name="part32"></a>
<h3>	3-2. タスク生成 (cre_tsk)
</h3>
	【エラーコード(ercd)】

	　E_OK		正常終了
	　E_SYS		システムエラー（カーネルが初期化されていない）
	　E_ID		不正ID番号（tskidが不正）
	　E_PAR		パラメータエラー（task,itskpri,stkszが不正）

	※他の点は、ハンドブックをご参照ください。

<a name="part33"></a>
<h3>	3-3. タスク起動 (sta_tsk)
</h3>
	【エラーコード(ercd)】

	　E_OK		正常終了
	　E_ID		不正ID番号（tskidが不正）
	　E_NOEXS	オブジェクトが存在していない
	　E_OBJ		オブジェクトの状態が不正

	※他の点は、ハンドブックをご参照ください。

<a name="part34"></a>
<h3>	3-4. ディスパッチ禁止 (dis_dsp)
</h3>
	※ハンドブックをご参照ください。

<a name="part35"></a>
<h3>	3-5. ディスパッチ許可 (ena_dsp)
</h3>
	※ハンドブックをご参照ください。

<a name="part36"></a>
<h3>	3-6. タスクのレディキュー回転 (rot_rdq)
</h3>
	【補足事項】

	　タスク独立部から rot_rdq(tskid=TPRI_RUN)を発行した場合は、その
	時実行中のタスクを含むレディキューを回転します。ディスパッチが遅
	延されている状態においては、ディスパッチが発行される直前の実行中
	のタスクを含むレディーキューの回転となります。

	※他の点は、ハンドブックをご参照ください。

<a name="part37"></a>
<h3>	3-7. 自タスクのタスクＩＤ参照 (get_tid)
</h3>
	※ハンドブックをご参照ください。

<a name="part38"></a>
<h3>	3-8. 自タスクを起床待ち状態へ移行 (slp_tsk,tslp_tsk)
</h3>
	※ハンドブックをご参照ください。

<a name="part39"></a>
<h3>	3-9. 他タスクの起床 (wup_tsk)
</h3>
	【エラーコード(ercd)】

	　E_OK		正常終了
	　E_ID		不正ID番号（tskidが不正）
	　E_NOEXS	オブジェクトが存在していない
	　E_OBJ		オブジェクトの状態が不正
	　E_OACV	キューイングまたはネストのオーバーフロー

	※他の点は、ハンドブックをご参照ください。

<a name="part310"></a>
<h3>	3-10. 割り込みハンドラから復帰 (ret_int)
</h3>
	【補足事項】

	a)rel.0.06c までに適用

        　ret_int は単なる return 文になっていますが、現在使い道はあり
        ません。

	b)rel.0.07に適用
	
	　ret_int が、単なる return 文からディスパッチ実行関数にかわり
	ました。ただし、割り込みハンドラの先頭（割込み禁止状態）で、
	vbgn_int をコールすることが必須です。

	※他の点は、ハンドブックをご参照ください。

<a name="part311"></a>
<h3>	3-11. 割り込みとディスパッチ禁止 (loc_cpu)
</h3>
	※ハンドブックをご参照ください。

<a name="part312"></a>
<h3>	3-12. 割り込みとディスパッチ許可 (unl_cpu)
</h3>
	※ハンドブックをご参照ください。

<a name="part313"></a>
<h3>	3-13. タスク遅延 (dly_tsk)
</h3>
	※ハンドブックをご参照ください。

<a name="part314"></a>
<h3>	3-14. システム状態参照 (ref_sys)
</h3>
	【エラーコード(ercd)】

	　E_OK		正常終了
	　E_SYS		システムエラー（カーネルが初期化されていない）
	　E_PAR		パラメータエラー

	※他の点は、ハンドブックをご参照ください。

<a name="part315"></a>
<h3>	3-15. 自タスク終了 (ext_tsk)
</h3>
	【補足事項】

	　他のタスクがアクティブになるまで、スタック領域はカーネルが使用
	しています。

	※他の点は、ハンドブックをご参照ください。

<a name="part316"></a>
<h3>	3-16. 自タスクの終了と削除 (exd_tsk)
</h3>
	【補足事項】

	　他のタスクがアクティブになるまで、スタック領域はカーネルが使用
	しています。

	※他の点は、ハンドブックをご参照ください。

<a name="part317"></a>
<h3>	3-17. 例外ハンドラ定義 (def_exc)
</h3>
	【補足事項】

	　定義可能な例外ハンドラは、ter_tsk によるタスクの終了ハンドラの
	みです。タスク独立部から起動した場合は、エラーコード E_CTX を返
	します。

	※他の点は、ハンドブックをご参照ください。

<a name="part318"></a>
<h3>	3-18. 他タスク強制終了 (ter_tsk)
</h3>

	※ハンドブックをご参照ください。

<a name="part319"></a>
<h3>	3-19. タスクの起床要求を無効化 (can_wup)
</h3>

	※ハンドブックをご参照ください。

<a name="part320"></a>
<h3>	3-20. 割り込みハンドラ復帰とタスク起床 (ret_wup)
</h3>

	※ハンドブックをご参照ください。

<a name="part321"></a>
<h3>	3-21. 割り込みハンドラ定義 (def_int)
</h3>
	【補足事項】

	　割り込みハンドラを静的に定義する場合は、このシステム
	コールを使用する必要はありません。動的に割り込みハンド
	ラを定義したい場合に使用します。

	　pk_dintのパケット形式の追加メンバinttblは、割り込み
	テーブルの先頭アドレスを格納します。割り込みアドレスを
	静的に定義している場合は NULL とします。(NADRではない)
	また、追加メンバintiniが NULL (こちらもNADRではない)で
	無い場合は、割り込み初期化ルーチンとして、def_intのな
	かから呼び出します。

	　尚、pk_dint=NADR=(-1)としても割り込みハンドラの定義
	解除は行われませんので、ご注意ください。

	※他の点は、ハンドブックをご参照ください。

	【実装例】

	　以下は例ですが、机上ですのでうまく行かないかもしれ
	ません。

	; 割り込みベクタ
		.section	V, CODE, ALIGN=2
		.org	xxxx
		.data.l	int_000

		.org	yyyy
		.data.l	int_001

	; 割り込みテーブル
		.section	D, DATA, ALIGN=2
		.align	2
		.export	_int_tbl
	_int_tbl
	int_000	.res.l	1
	int_001	.res.l	1

	/* 割り込みハンドラ */
	#pragma interrupt int_yyy
	void int_yyy( void )
	{
		vbgn_int();	/* 必須 */
		/*
		ここで、必要があれば割込み要求フラグ解除
		*/
		/*
		ここで、実際の処理
		*/
		ret_int();	/* 必須（またはret_wup(zz)） */
	}
	/* 割り込みの初期化 */
	void int_yyy_ini( void )
	{
		/*
		ここで、割り込みの初期化
		*/
	}

	/* 定義 */
	#define INT_001 1
	extern FP int_tbl[];
	T_DINT dint;

		/*
		なにがしかの処理
		*/
		dint.intatr = TA_HLNG;
		dint.inthdr = int_yyy;
		dint.inttbl = int_tbl;
		dint_intini = int_yyy_ini;
		def_int( INT_001, &dint );
		/*
		なにがしかの処理
		*/


<a name="part4"></a>
<h2>	４．配布内容
</h2>
<a name="part41"></a>
<h3>	4-1. カーネル（kernel.obj, kernel.h, kernel.htm）
</h3>
	　カーネル本体とそのヘッダファイルとこのファイルです。

<a name="part42"></a>
<h3>	4-2. ＣＰＵのＣＣＲ操作関数（machine.obj, machine.h）
</h3>
	　ＣＰＵのＣＣＲ操作関数とそのヘッダファイルです。

	　AKI-H8マイコン専用Ｃコンパイラには、ＣＣＲ操作関数が含まれて
	いなかったので、一部拡張して作成しました。

	　set_ccr : ＣＣＲをセット
	　get_ccr : ＣＣＲの状態を取得
	　and_ccr : ＣＣＲをアンドセット
	　or_ccr : ＣＣＲをオアセット
	　xor_ccr : ＣＣＲをエクスクルーシブオアセット

	　get_and_ccr : ＣＣＲをアンドセット（操作前のＣＣＲの状態を取得）
	　get_or_ccr : ＣＣＲをオアセット（操作前のＣＣＲの状態を取得）
	　get_xor_ccr : ＣＣＲをエクスクルーシブオアセット
			（操作前のＣＣＲの状態を取得）

<a name="part43"></a>
<h3>	4-3. ＬＣＤ表示ドライバ（lcddrv.obj, lcddrv.h）
</h3>
	　ＬＣＤの表示ドライバとヘッダファイルです。

	　このドライバでは、時間待ちを dly_tsk システムコールを使用
	していますので、カーネルの初期化後に実行する様にしてください。

	　対応制御コード

		0x0d (CR) 復帰
		0x0a (LF) 改行

		※ ２行目の最終を超えた場合は、自動的に復帰改行します。

	　エスケープ・シーケンス

		カーソル移動（ESC=lc）	カーソルをｌ行ｃカラムに移動させます。
					パラメータｌとｃは、バイナリで0x20の
					オフセットを付けて指定します。
					１行目の１カラムの指定は文字列表記で、
					"\x1b=\x21\x21" となります。
					３行目以上または４０カラム以上の指定
					はそれぞれ１行目、１カラムになります。

		ＣＧＲＡＭ定義（ESCCa）	ＣＧＲＡＭのアドレスaから続くデータを
					書き込みます。
					アドレスは、バイナリで0x40のオフセット
					を付けて指定します。
					パターンデータは、ＭＳＢを１として与え
					ます。（制御コードの回避）
					データとして 0xff を与えるとこのシーケ
					ンスを終了して、以降はＤＤＲＡＭへの通
					常表示となります。（ キャラクタコード
					は 0x80 から 0x87 です。）
					ＣＧＲＡＭの０をクリアするには、文字列
					表記で、"\x1bC\x40\x80\x80\x80\x80\x80
					\x80\x80\x80\xff" となります。

	　他の制御コードに対応していません。まだ、未完成です。

	　lcd_ini : 初期化
	　lcd_putc : 一文字出力
	　lcd_puts : 文字列出力

<a name="part44"></a>
<h3>	4-4. セットアップ（setup.mar, system.h, ioregs.h）
</h3>
	　セットアッププログラムソースと各種定義ヘッダファイルです。

<a name="part45"></a>
<h3>	4-5. サンプルファイル（main.c, makefile）
</h3>
	サンプルソースと生成用メイクファイルです。　

<a name="part5"></a>
<h2>	５．組み込み手順
</h2>
	　添付サンプル (setup.mar, main.c, makefile) をご覧ください。

<a name="part6"></a>
<h2>	６．注意事項
</h2>
	　デバックは行っていませんので、ご使用に当たっては十分ご注
	意願います。このソフトウエアを使用したことによるすべての損
	害について、作者は一切その責任を負わないものとします。

<a name="part7"></a>
<h2>	７．その他
</h2>
	　このプログラムは、著作権を放棄していない「フリーソフトウ
	エア」です。注意事項を十分ご確認の上、自由に使用していただ
	いてかまいません。

<h3>	7-1 連絡先
</h3>
	　このプログラムに対する、ご意見、ご要望、ご質問、ご感想、
	バグ情報などございましたら下記の宛先までメールをお願い致し
	ます。尚、頂いた、ご意見、ご要望、ご質問は、ホームページ上
	で、公開することもありますので、予めご了承ください。

		AKIYA	e-mail:aki_chi@live.jp

<h3>	7-2 履歴
</h3>
	rel.0.07a	2000/2/27

	・ヘッダ kernel.h の定義(FP)を変更。
	・添付 lcddrv.obj の文字コードH'A0〜H'FFの文字化けを修正。
	・添付 ioregs.h のD/A関連レジスタ定義を修正。
	・添付 main.c のヘッダ変更によるワーニングを修正。

	rel.0.07	1999/7/31

	・システムコールの ret_int をマクロから関数に変更。
	・システムコールの ret_wup をサポート。
	・タスク独立部から呼び出し可能なシステムコールについて
	　呼び出せるように修正。（割り込みルーチン向け）

	rel.0.06c	1999/5/23

	・システムコールの dis_dsp でディスパッチを禁止したにも
	　かかわらず、ディスパッチが実行されてしまうのを修正。

	rel.0.06b	1999/3/13

	・システムコールの wup_tsk の不具合を修正。

	rel.0.06a	1999/2/11

	・システムコールの can_wup の不具合を修正。

	rel.0.06	1999/2/6

	・システムコールの can_wup をサポート。

	rel.0.05	1998/11/22

	・システムコールの def_exc, ter_tsk をサポート。

	rel.0.04	1998/11/3

	・タスクの削除でスタックを開放するように変更。
	・exd_tsk でタスクが削除されないのを修正。

	rel.0.03	1998/10/11

	・ディスパッチロジックを修正。
	・システムコールの ext_tsk, exd_tsk をサポート。
	・ディスパッチ禁止状態で get_tid を実行すると FALSE を返すのを修正。

	rel.0.02	1998/9/27

	・スタック、クロック値を外部変数としてカーネルに指示する構造に変更。
	・使用するタイマーを選択できるように変更。
	・システムコールの rot_rdq をサポート。
	・タスク起動時に正常終了コードが E_OBJ になっていたのを E_OK に修正。

	rel.0.01	1998/9/15	公開

</pre>
</body>
</html>